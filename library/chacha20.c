/**
 * \file chacha20.c
 *
 * \brief ChaCha20 cipher.
 *
 * \author Daniel King <damaki.gh@gmail.com>
 *
 *  Copyright The Mbed TLS Contributors
 *  SPDX-License-Identifier: Apache-2.0
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may
 *  not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

#include "common.h"

#if defined(MBEDTLS_CHACHA20_C)

#include "mbedtls/chacha20.h"
#include "mbedtls/platform_util.h"
#include "mbedtls/error.h"

#include <stddef.h>
#include <string.h>

#include "mbedtls/platform.h"

#if !defined(MBEDTLS_CHACHA20_ALT)

#define ROTL32(value, amount) \
    ((uint32_t) ((value) << (amount)) | ((value) >> (32U - (amount))))

#define CHACHA20_CTR_INDEX (12U)

#define CHACHA20_BLOCK_SIZE_BYTES (4U * 16U)

/**
 * \brief           ChaCha20 quarter round operation.
 *
 *                  The quarter round is defined as follows (from RFC 7539):
 *                      1.  a += b; d ^= a; d <<<= 16;
 *                      2.  c += d; b ^= c; b <<<= 12;
 *                      3.  a += b; d ^= a; d <<<= 8;
 *                      4.  c += d; b ^= c; b <<<= 7;
 *
 * \param state     ChaCha20 state to modify.
 * \param a         The index of 'a' in the state.
 * \param b         The index of 'b' in the state.
 * \param c         The index of 'c' in the state.
 * \param d         The index of 'd' in the state.
 */
static inline void chacha20_quarter_round(uint32_t state[16],
                                          size_t a,
                                          size_t b,
                                          size_t c,
                                          size_t d)
{
    /* a += b; d ^= a; d <<<= 16; */
    state[a] = state[a] + state[b];
    state[d] = state[d] ^ state[a];
    state[d] = ROTL32(state[d], 16U);

    /* c += d; b ^= c; b <<<= 12 */
    state[c] = state[c] + state[d];
    state[b] = state[b] ^ state[c];
    state[b] = ROTL32(state[b], 12U);

    /* a += b; d ^= a; d <<<= 8; */
    state[a] = state[a] + state[b];
    state[d] = state[d] ^ state[a];
    state[d] = ROTL32(state[d], 8U);

    /* c += d; b ^= c; b <<<= 7; */
    state[c] = state[c] + state[d];
    state[b] = state[b] ^ state[c];
    state[b] = ROTL32(state[b], 7U);
}

/**
 * \brief           Perform the ChaCha20 inner block operation.
 *
 *                  This function performs two rounds: the column round and the
 *                  diagonal round.
 *
 * \param state     The ChaCha20 state to update.
 */
static void chacha20_inner_block(uint32_t state[16])
{
    chacha20_quarter_round(state, 0U, 4U, 8U,  12U);
    chacha20_quarter_round(state, 1U, 5U, 9U,  13U);
    chacha20_quarter_round(state, 2U, 6U, 10U, 14U);
    chacha20_quarter_round(state, 3U, 7U, 11U, 15U);

    chacha20_quarter_round(state, 0U, 5U, 10U, 15U);
    chacha20_quarter_round(state, 1U, 6U, 11U, 12U);
    chacha20_quarter_round(state, 2U, 7U, 8U,  13U);
    chacha20_quarter_round(state, 3U, 4U, 9U,  14U);
}

/**
 * \brief               Generates a keystream block.
 *
 * \param initial_state The initial ChaCha20 state (key, nonce, counter).
 * \param keystream     Generated keystream bytes are written to this buffer.
 */
static void chacha20_block(const uint32_t initial_state[16],
                           unsigned char keystream[64])
{
    uint32_t working_state[16];
    size_t i;

    memcpy(working_state,
           initial_state,
           CHACHA20_BLOCK_SIZE_BYTES);

    for (i = 0U; i < 10U; i++) {
        chacha20_inner_block(working_state);
    }

    working_state[0]  = working_state[0]  + initial_state[0];
    working_state[1]  = working_state[1]  + initial_state[1];
    working_state[2]  = working_state[2]  + initial_state[2];
    working_state[3]  = working_state[3]  + initial_state[3];
    working_state[4]  = working_state[4]  + initial_state[4];
    working_state[5]  = working_state[5]  + initial_state[5];
    working_state[6]  = working_state[6]  + initial_state[6];
    working_state[7]  = working_state[7]  + initial_state[7];
    working_state[8]  = working_state[8]  + initial_state[8];
    working_state[9]  = working_state[9]  + initial_state[9];
    working_state[10] = working_state[10] + initial_state[10];
    working_state[11] = working_state[11] + initial_state[11];
    working_state[12] = working_state[12] + initial_state[12];
    working_state[13] = working_state[13] + initial_state[13];
    working_state[14] = working_state[14] + initial_state[14];
    working_state[15] = working_state[15] + initial_state[15];

    for (i = 0U; i < 16U; i++) {
        size_t offset = i * 4U;

        MBEDTLS_PUT_UINT32_LE(working_state[i], keystream, offset);
    }

    mbedtls_platform_zeroize(working_state, sizeof(working_state));
}

void mbedtls_chacha20_init(mbedtls_chacha20_context *ctx)
{
    mbedtls_platform_zeroize(ctx->state, sizeof(ctx->state));
    mbedtls_platform_zeroize(ctx->keystream8, sizeof(ctx->keystream8));

    /* Initially, there's no keystream bytes available */
    ctx->keystream_bytes_used = CHACHA20_BLOCK_SIZE_BYTES;
}

void mbedtls_chacha20_free(mbedtls_chacha20_context *ctx)
{
    if (ctx != NULL) {
        mbedtls_platform_zeroize(ctx, sizeof(mbedtls_chacha20_context));
    }
}

int mbedtls_chacha20_setkey(mbedtls_chacha20_context *ctx,
                            const unsigned char key[32])
{
    /* ChaCha20 constants - the string "expand 32-byte k" */
    ctx->state[0] = 0x61707865;
    ctx->state[1] = 0x3320646e;
    ctx->state[2] = 0x79622d32;
    ctx->state[3] = 0x6b206574;

    /* Set key */
    ctx->state[4]  = MBEDTLS_GET_UINT32_LE(key, 0U);
    ctx->state[5]  = MBEDTLS_GET_UINT32_LE(key, 4U);
    ctx->state[6]  = MBEDTLS_GET_UINT32_LE(key, 8U);
    ctx->state[7]  = MBEDTLS_GET_UINT32_LE(key, 12U);
    ctx->state[8]  = MBEDTLS_GET_UINT32_LE(key, 16U);
    ctx->state[9]  = MBEDTLS_GET_UINT32_LE(key, 20U);
    ctx->state[10] = MBEDTLS_GET_UINT32_LE(key, 24U);
    ctx->state[11] = MBEDTLS_GET_UINT32_LE(key, 28U);

    return 0;
}

int mbedtls_chacha20_starts(mbedtls_chacha20_context *ctx,
                            const unsigned char nonce[12],
                            uint32_t counter)
{
    /* Counter */
    ctx->state[12] = counter;

    /* Nonce */
    ctx->state[13] = MBEDTLS_GET_UINT32_LE(nonce, 0U);
    ctx->state[14] = MBEDTLS_GET_UINT32_LE(nonce, 4U);
    ctx->state[15] = MBEDTLS_GET_UINT32_LE(nonce, 8U);

    mbedtls_platform_zeroize(ctx->keystream8, sizeof(ctx->keystream8));

    /* Initially, there's no keystream bytes available */
    ctx->keystream_bytes_used = CHACHA20_BLOCK_SIZE_BYTES;

    return 0;
}

int mbedtls_chacha20_update(mbedtls_chacha20_context *ctx,
                            size_t size,
                            const unsigned char *input,
                            unsigned char *output)
{
    size_t offset = 0U;

    /* Use leftover keystream bytes, if available */
    while ((size > 0U) && (ctx->keystream_bytes_used < CHACHA20_BLOCK_SIZE_BYTES)) {
        output[offset] = input[offset]
                         ^ ctx->keystream8[ctx->keystream_bytes_used];

        ctx->keystream_bytes_used++;
        offset = offset + 1U;
        size = size - 1U;
    }

    /* Process full blocks */
    while (size >= CHACHA20_BLOCK_SIZE_BYTES) {
        /* Generate new keystream block and increment counter */
        chacha20_block(ctx->state, ctx->keystream8);
        ctx->state[CHACHA20_CTR_INDEX]++;

        mbedtls_xor(output + offset, input + offset, ctx->keystream8, 64U);

        offset = offset + CHACHA20_BLOCK_SIZE_BYTES;
        size   = size   - CHACHA20_BLOCK_SIZE_BYTES;
    }

    /* Last (partial) block */
    if (size > 0U) {
        /* Generate new keystream block and increment counter */
        chacha20_block(ctx->state, ctx->keystream8);
        ctx->state[CHACHA20_CTR_INDEX]++;

        mbedtls_xor(output + offset, input + offset, ctx->keystream8, size);

        ctx->keystream_bytes_used = size;

    }

    return 0;
}

int mbedtls_chacha20_crypt(const unsigned char key[32],
                           const unsigned char nonce[12],
                           uint32_t counter,
                           size_t data_len,
                           const unsigned char *input,
                           unsigned char *output)
{
    mbedtls_chacha20_context ctx;
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;

    mbedtls_chacha20_init(&ctx);

    ret = mbedtls_chacha20_setkey(&ctx, key);
    if (ret != 0) {
        goto cleanup;
    }

    ret = mbedtls_chacha20_starts(&ctx, nonce, counter);
    if (ret != 0) {
        goto cleanup;
    }

    ret = mbedtls_chacha20_update(&ctx, data_len, input, output);

cleanup:
    mbedtls_chacha20_free(&ctx);
    return ret;
}

#endif /* !MBEDTLS_CHACHA20_ALT */

#if defined(MBEDTLS_SELF_TEST)

static const unsigned char test_keys[2][32] =
{
    {
        0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
        0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
        0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
        0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U
    },
    {
        0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
        0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
        0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
        0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x01U
    }
};

static const unsigned char test_nonces[2][12] =
feature/chacha20_enc_dec{
    {
        0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
        0x00U, 0x00U, 0x00U, 0x00U
    },
    {
        0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
        0x00U, 0x00U, 0x00U, 0x02U
    }
};

static const uint32_t test_counters[2] =
{
    0U,
    1U
};

static const unsigned char test_input[2][375] =
{
    {
        0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
        0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
        0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
        0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
        0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
        0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
        0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
        0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U
    },
    {
        0x41U, 0x6eU, 0x79U, 0x20U, 0x73U, 0x75U, 0x62U, 0x6dU,
        0x69U, 0x73U, 0x73U, 0x69U, 0x6fU, 0x6eU, 0x20U, 0x74U,
        0x6fU, 0x20U, 0x74U, 0x68U, 0x65U, 0x20U, 0x49U, 0x45U,
        0x54U, 0x46U, 0x20U, 0x69U, 0x6eU, 0x74U, 0x65U, 0x6eU,
        0x64U, 0x65U, 0x64U, 0x20U, 0x62U, 0x79U, 0x20U, 0x74U,
        0x68U, 0x65U, 0x20U, 0x43U, 0x6fU, 0x6eU, 0x74U, 0x72U,
        0x69U, 0x62U, 0x75U, 0x74U, 0x6fU, 0x72U, 0x20U, 0x66U,
        0x6fU, 0x72U, 0x20U, 0x70U, 0x75U, 0x62U, 0x6cU, 0x69U,
        0x63U, 0x61U, 0x74U, 0x69U, 0x6fU, 0x6eU, 0x20U, 0x61U,
        0x73U, 0x20U, 0x61U, 0x6cU, 0x6cU, 0x20U, 0x6fU, 0x72U,
        0x20U, 0x70U, 0x61U, 0x72U, 0x74U, 0x20U, 0x6fU, 0x66U,
        0x20U, 0x61U, 0x6eU, 0x20U, 0x49U, 0x45U, 0x54U, 0x46U,
        0x20U, 0x49U, 0x6eU, 0x74U, 0x65U, 0x72U, 0x6eU, 0x65U,
        0x74U, 0x2dU, 0x44U, 0x72U, 0x61U, 0x66U, 0x74U, 0x20U,
        0x6fU, 0x72U, 0x20U, 0x52U, 0x46U, 0x43U, 0x20U, 0x61U,
        0x6eU, 0x64U, 0x20U, 0x61U, 0x6eU, 0x79U, 0x20U, 0x73U,
        0x74U, 0x61U, 0x74U, 0x65U, 0x6dU, 0x65U, 0x6eU, 0x74U,
        0x20U, 0x6dU, 0x61U, 0x64U, 0x65U, 0x20U, 0x77U, 0x69U,
        0x74U, 0x68U, 0x69U, 0x6eU, 0x20U, 0x74U, 0x68U, 0x65U,
        0x20U, 0x63U, 0x6fU, 0x6eU, 0x74U, 0x65U, 0x78U, 0x74U,
        0x20U, 0x6fU, 0x66U, 0x20U, 0x61U, 0x6eU, 0x20U, 0x49U,
        0x45U, 0x54U, 0x46U, 0x20U, 0x61U, 0x63U, 0x74U, 0x69U,
        0x76U, 0x69U, 0x74U, 0x79U, 0x20U, 0x69U, 0x73U, 0x20U,
        0x63U, 0x6fU, 0x6eU, 0x73U, 0x69U, 0x64U, 0x65U, 0x72U,
        0x65U, 0x64U, 0x20U, 0x61U, 0x6eU, 0x20U, 0x22U, 0x49U,
        0x45U, 0x54U, 0x46U, 0x20U, 0x43U, 0x6fU, 0x6eU, 0x74U,
        0x72U, 0x69U, 0x62U, 0x75U, 0x74U, 0x69U, 0x6fU, 0x6eU,
        0x22U, 0x2eU, 0x20U, 0x53U, 0x75U, 0x63U, 0x68U, 0x20U,
        0x73U, 0x74U, 0x61U, 0x74U, 0x65U, 0x6dU, 0x65U, 0x6eU,
        0x74U, 0x73U, 0x20U, 0x69U, 0x6eU, 0x63U, 0x6cU, 0x75U,
        0x64U, 0x65U, 0x20U, 0x6fU, 0x72U, 0x61U, 0x6cU, 0x20U,
        0x73U, 0x74U, 0x61U, 0x74U, 0x65U, 0x6dU, 0x65U, 0x6eU,
        0x74U, 0x73U, 0x20U, 0x69U, 0x6eU, 0x20U, 0x49U, 0x45U,
        0x54U, 0x46U, 0x20U, 0x73U, 0x65U, 0x73U, 0x73U, 0x69U,
        0x6fU, 0x6eU, 0x73U, 0x2cU, 0x20U, 0x61U, 0x73U, 0x20U,
        0x77U, 0x65U, 0x6cU, 0x6cU, 0x20U, 0x61U, 0x73U, 0x20U,
        0x77U, 0x72U, 0x69U, 0x74U, 0x74U, 0x65U, 0x6eU, 0x20U,
        0x61U, 0x6eU, 0x64U, 0x20U, 0x65U, 0x6cU, 0x65U, 0x63U,
        0x74U, 0x72U, 0x6fU, 0x6eU, 0x69U, 0x63U, 0x20U, 0x63U,
        0x6fU, 0x6dU, 0x6dU, 0x75U, 0x6eU, 0x69U, 0x63U, 0x61U,
        0x74U, 0x69U, 0x6fU, 0x6eU, 0x73U, 0x20U, 0x6dU, 0x61U,
        0x64U, 0x65U, 0x20U, 0x61U, 0x74U, 0x20U, 0x61U, 0x6eU,
        0x79U, 0x20U, 0x74U, 0x69U, 0x6dU, 0x65U, 0x20U, 0x6fU,
        0x72U, 0x20U, 0x70U, 0x6cU, 0x61U, 0x63U, 0x65U, 0x2cU,
        0x20U, 0x77U, 0x68U, 0x69U, 0x63U, 0x68U, 0x20U, 0x61U,
        0x72U, 0x65U, 0x20U, 0x61U, 0x64U, 0x64U, 0x72U, 0x65U,
        0x73U, 0x73U, 0x65U, 0x64U, 0x20U, 0x74U, 0x6fU
    }
};

static const unsigned char test_output[2][375] =
{
    {
        0x76U, 0xb8U, 0xe0U, 0xadU, 0xa0U, 0xf1U, 0x3dU, 0x90U,
        0x40U, 0x5dU, 0x6aU, 0xe5U, 0x53U, 0x86U, 0xbdU, 0x28U,
        0xbdU, 0xd2U, 0x19U, 0xb8U, 0xa0U, 0x8dU, 0xedU, 0x1aU,
        0xa8U, 0x36U, 0xefU, 0xccU, 0x8bU, 0x77U, 0x0dU, 0xc7U,
        0xdaU, 0x41U, 0x59U, 0x7cU, 0x51U, 0x57U, 0x48U, 0x8dU,
        0x77U, 0x24U, 0xe0U, 0x3fU, 0xb8U, 0xd8U, 0x4aU, 0x37U,
        0x6aU, 0x43U, 0xb8U, 0xf4U, 0x15U, 0x18U, 0xa1U, 0x1cU,
        0xc3U, 0x87U, 0xb6U, 0x69U, 0xb2U, 0xeeU, 0x65U, 0x86U
    },
    {
        0xa3U, 0xfbU, 0xf0U, 0x7dU, 0xf3U, 0xfaU, 0x2fU, 0xdeU,
        0x4fU, 0x37U, 0x6cU, 0xa2U, 0x3eU, 0x82U, 0x73U, 0x70U,
        0x41U, 0x60U, 0x5dU, 0x9fU, 0x4fU, 0x4fU, 0x57U, 0xbdU,
        0x8cU, 0xffU, 0x2cU, 0x1dU, 0x4bU, 0x79U, 0x55U, 0xecU,
        0x2aU, 0x97U, 0x94U, 0x8bU, 0xd3U, 0x72U, 0x29U, 0x15U,
        0xc8U, 0xf3U, 0xd3U, 0x37U, 0xf7U, 0xd3U, 0x70U, 0x05U,
        0x0eU, 0x9eU, 0x96U, 0xd6U, 0x47U, 0xb7U, 0xc3U, 0x9fU,
        0x56U, 0xe0U, 0x31U, 0xcaU, 0x5eU, 0xb6U, 0x25U, 0x0dU,
        0x40U, 0x42U, 0xe0U, 0x27U, 0x85U, 0xecU, 0xecU, 0xfaU,
        0x4bU, 0x4bU, 0xb5U, 0xe8U, 0xeaU, 0xd0U, 0x44U, 0x0eU,
        0x20U, 0xb6U, 0xe8U, 0xdbU, 0x09U, 0xd8U, 0x81U, 0xa7U,
        0xc6U, 0x13U, 0x2fU, 0x42U, 0x0eU, 0x52U, 0x79U, 0x50U,
        0x42U, 0xbdU, 0xfaU, 0x77U, 0x73U, 0xd8U, 0xa9U, 0x05U,
        0x14U, 0x47U, 0xb3U, 0x29U, 0x1cU, 0xe1U, 0x41U, 0x1cU,
        0x68U, 0x04U, 0x65U, 0x55U, 0x2aU, 0xa6U, 0xc4U, 0x05U,
        0xb7U, 0x76U, 0x4dU, 0x5eU, 0x87U, 0xbeU, 0xa8U, 0x5aU,
        0xd0U, 0x0fU, 0x84U, 0x49U, 0xedU, 0x8fU, 0x72U, 0xd0U,
        0xd6U, 0x62U, 0xabU, 0x05U, 0x26U, 0x91U, 0xcaU, 0x66U,
        0x42U, 0x4bU, 0xc8U, 0x6dU, 0x2dU, 0xf8U, 0x0eU, 0xa4U,
        0x1fU, 0x43U, 0xabU, 0xf9U, 0x37U, 0xd3U, 0x25U, 0x9dU,
        0xc4U, 0xb2U, 0xd0U, 0xdfU, 0xb4U, 0x8aU, 0x6cU, 0x91U,
        0x39U, 0xddU, 0xd7U, 0xf7U, 0x69U, 0x66U, 0xe9U, 0x28U,
        0xe6U, 0x35U, 0x55U, 0x3bU, 0xa7U, 0x6cU, 0x5cU, 0x87U,
        0x9dU, 0x7bU, 0x35U, 0xd4U, 0x9eU, 0xb2U, 0xe6U, 0x2bU,
        0x08U, 0x71U, 0xcdU, 0xacU, 0x63U, 0x89U, 0x39U, 0xe2U,
        0x5eU, 0x8aU, 0x1eU, 0x0eU, 0xf9U, 0xd5U, 0x28U, 0x0fU,
        0xa8U, 0xcaU, 0x32U, 0x8bU, 0x35U, 0x1cU, 0x3cU, 0x76U,
        0x59U, 0x89U, 0xcbU, 0xcfU, 0x3dU, 0xaaU, 0x8bU, 0x6cU,
        0xccU, 0x3aU, 0xafU, 0x9fU, 0x39U, 0x79U, 0xc9U, 0x2bU,
        0x37U, 0x20U, 0xfcU, 0x88U, 0xdcU, 0x95U, 0xedU, 0x84U,
        0xa1U, 0xbeU, 0x05U, 0x9cU, 0x64U, 0x99U, 0xb9U, 0xfdU,
        0xa2U, 0x36U, 0xe7U, 0xe8U, 0x18U, 0xb0U, 0x4bU, 0x0bU,
        0xc3U, 0x9cU, 0x1eU, 0x87U, 0x6bU, 0x19U, 0x3bU, 0xfeU,
        0x55U, 0x69U, 0x75U, 0x3fU, 0x88U, 0x12U, 0x8cU, 0xc0U,
        0x8aU, 0xaaU, 0x9bU, 0x63U, 0xd1U, 0xa1U, 0x6fU, 0x80U,
        0xefU, 0x25U, 0x54U, 0xd7U, 0x18U, 0x9cU, 0x41U, 0x1fU,
        0x58U, 0x69U, 0xcaU, 0x52U, 0xc5U, 0xb8U, 0x3fU, 0xa3U,
        0x6fU, 0xf2U, 0x16U, 0xb9U, 0xc1U, 0xd3U, 0x00U, 0x62U,
        0xbeU, 0xbcU, 0xfdU, 0x2dU, 0xc5U, 0xbcU, 0xe0U, 0x91U,
        0x19U, 0x34U, 0xfdU, 0xa7U, 0x9aU, 0x86U, 0xf6U, 0xe6U,
        0x98U, 0xceU, 0xd7U, 0x59U, 0xc3U, 0xffU, 0x9bU, 0x64U,
        0x77U, 0x33U, 0x8fU, 0x3dU, 0xa4U, 0xf9U, 0xcdU, 0x85U,
        0x14U, 0xeaU, 0x99U, 0x82U, 0xccU, 0xafU, 0xb3U, 0x41U,
        0xb2U, 0x38U, 0x4dU, 0xd9U, 0x02U, 0xf3U, 0xd1U, 0xabU,
        0x7aU, 0xc6U, 0x1dU, 0xd2U, 0x9cU, 0x6fU, 0x21U, 0xbaU,
        0x5bU, 0x86U, 0x2fU, 0x37U, 0x30U, 0xe3U, 0x7cU, 0xfdU,
        0xc4U, 0xfdU, 0x80U, 0x6cU, 0x22U, 0xf2U, 0x21U
    }
};

static const size_t test_lengths[2] =
{
    64U,
    375U
};

/* Make sure no other definition is already present. */
#undef ASSERT

#define ASSERT(cond, args)              \
    do                                  \
    {                                   \
        if (!(cond))                    \
        {                               \
            if (verbose != 0)           \
            mbedtls_printf args;        \
                                        \
            return -1;                  \
        }                               \
    }                                   \
    while (0)

int mbedtls_chacha20_self_test(int verbose)
{
    unsigned char output[381];
    unsigned i;
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;

    for (i = 0U; i < 2U; i++) {
        if (verbose != 0) {
            mbedtls_printf("  ChaCha20 test %u ", i);
        }

        ret = mbedtls_chacha20_crypt(test_keys[i],
                                     test_nonces[i],
                                     test_counters[i],
                                     test_lengths[i],
                                     test_input[i],
                                     output);

        ASSERT(0 == ret, ("error code: %i\n", ret));

        ASSERT(0 == memcmp(output, test_output[i], test_lengths[i]),
               ("failed (output)\n"));

        if (verbose != 0) {
            mbedtls_printf("passed\n");
        }
    }

    if (verbose != 0) {
        mbedtls_printf("\n");
    }

    return 0;
}

#endif /* MBEDTLS_SELF_TEST */

#endif /* !MBEDTLS_CHACHA20_C */
